/*@!Encoding:936*/
includes
{
  
}

variables
{
    struct eth_header
    {
        qword dMAC;
        qword sMAC;
        word vlanID;
        word etherType;
    };
    
    struct ipv4_header
    {
        char sIPv4Addr_str[16];
        char dIPv4Addr_str[16];
        dword protocol;
        
    };
    
    struct ipv6_header
    {
        char sIPv6Addr_str[40];
        char dIPv6Addr_str[40];
        dword protocol;
    };
  
}

//设置再哪个总线，等待报文
long SetListenBus(char listen_bus[])
{
  dword busContext;
  dword retVal;
  //Listen CAN1
  busContext = GetBusNameContext(listen_bus);
  //busContext = GetBusNameContext(eCAN,1);
  retVal =  SetBusContext(busContext);
  return retVal;
}




/// <GetEthPacket>
long TestWaitForEth_ETH(char bus[], ethernetPacket* pkt,char sMAC_str[], char dMAC_str[], word vlanID, word etherType,dword flags, dword aTimeout)
{
    long ret;
    qword sMAC,dMAC;
    sMAC=EthGetMacAddressAsNumber(sMAC_str);
    dMAC=EthGetMacAddressAsNumber(dMAC_str);
    SetListenBus(bus);
    
    ret=TestWaitForEthernetPacket(sMAC,dMAC,vlanID,etherType,flags,aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_ETH_Switch_Mode(char bus[], byte dir, ethernetPacket* pkt,char sMAC_str[], char dMAC_str[], word vlanID, word etherType,dword flags, dword aTimeout)
{
    long ret;
    
    ret=TestWaitForEth_ETH(bus, pkt,sMAC_str, dMAC_str, vlanID, etherType,flags, aTimeout);
    
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
    }
    else
    {
        return 0;
    }
    
    
    ret=TestWaitForEth_ETH(bus, pkt,sMAC_str, dMAC_str, vlanID, etherType,flags, aTimeout);
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        return 0;
    }
    return 0;
    
}

/// <GetEthPacket>
long TestWaitForEth_IPv4(char bus[], ethernetPacket* pkt,char sIPv4_str[], char dIPv4_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    SetListenBus(bus);
    
    
    ret=TestWaitForEthernetPacket(IpGetAddressAsNumber(sIPv4_str), IpGetAddressAsNumber(dIPv4_str), protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}
/// <GetEthPacket>
long TestWaitForEth_IPv4_Switch_Mode(char bus[], byte dir, ethernetPacket* pkt,char sIPv4_str[], char dIPv4_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    
    ret=TestWaitForEth_IPv4(bus, pkt,sIPv4_str, dIPv4_str, protocol, sPort, dPort, flags, aTimeout);
    
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
    }
    else
    {
        return 0;
    }
    
    
    ret=TestWaitForEth_IPv4(bus, pkt,sIPv4_str, dIPv4_str, protocol, sPort, dPort, flags, aTimeout);
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        return 0;
    }
    return 0;
    
}

/// <GetEthPacket>
long TestWaitForEth_TCP_IPv4(char bus[], ethernetPacket* pkt,char sIPv4_str[], char dIPv4_str[], dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    const dword protocol=6;//TCP
    SetListenBus(bus);
    
    
    ret=TestWaitForEthernetPacket(IpGetAddressAsNumber(sIPv4_str), IpGetAddressAsNumber(dIPv4_str), protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_TCP_IPv4_Switch_Mode(char bus[], byte dir, ethernetPacket* pkt,char sIPv4_str[], char dIPv4_str[], dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    
    ret=TestWaitForEth_TCP_IPv4(bus, pkt,sIPv4_str, dIPv4_str, sPort, dPort, flags, aTimeout);
    
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
    }
    else
    {
        return 0;
    }
    
    
    ret=TestWaitForEth_TCP_IPv4(bus, pkt,sIPv4_str, dIPv4_str, sPort, dPort, flags, aTimeout);
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        return 0;
    }
    return 0;
    
}

/// <GetEthPacket>
long TestWaitForEth_UDP_IPv4(char bus[], ethernetPacket* pkt,char sIPv4_str[], char dIPv4_str[], dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    const dword protocol=17;//TCP
    SetListenBus(bus);
    
    
    ret=TestWaitForEthernetPacket(IpGetAddressAsNumber(sIPv4_str), IpGetAddressAsNumber(dIPv4_str), protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_UDP_IPv4_Switch_Mode(char bus[],
    ethernetPacket* pkt,
    byte dir,
    char sIPv4_str[],
    char dIPv4_str[],
    dword sPort,
    dword dPort,
    dword flags,
    dword aTimeout)
{
    long ret;
    
    ret=TestWaitForEth_UDP_IPv4(bus,pkt,sIPv4_str,dIPv4_str,sPort,dPort,flags,aTimeout);
    
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
    }
    else
    {
        return 0;
    }
    
    
    ret=TestWaitForEth_UDP_IPv4(bus,pkt,sIPv4_str,dIPv4_str,sPort,dPort,flags,aTimeout);
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        return 0;
    }
    return 0;
}

/// <GetEthPacket>
long TestWaitForEth_IPv6(char bus[], ethernetPacket* pkt,char sIPv6_str[], char dIPv6_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    byte sIPv6[16], dIPv6[16];
    dword result;
    
    result = IpGetAddressAsArray( sIPv6_str, sIPv6);
    if (result != 0)
    {
        testStepFail("sIPv6 %s is wrong",sIPv6_str);
        return 0;
    }
    
    result = IpGetAddressAsArray( dIPv6_str, dIPv6);
    if (result != 0)
    {
        testStepFail("dIPv6 %s is wrong",dIPv6_str);
        return 0;
    }
    
    
    SetListenBus(bus);
    
    ret=TestWaitForEthernetPacket(sIPv6, dIPv6, protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_IPv6_Switch_Mode(char bus[], byte dir, ethernetPacket* pkt,char sIPv6_str[], char dIPv6_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    
    ret=TestWaitForEth_IPv6(bus, pkt,sIPv6_str, dIPv6_str, protocol, sPort, dPort, flags, aTimeout);
    
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
    }
    else
    {
        return 0;
    }
    
    
    ret=TestWaitForEth_IPv6(bus, pkt,sIPv6_str, dIPv6_str, protocol, sPort, dPort, flags, aTimeout);
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        return 0;
    }
    return 0;
    
}


/// <GetEthPacket>
long TestWaitForEth_ETH_IPv4(char bus[], ethernetPacket* pkt,char sMAC_str[], char dMAC_str[], word vlanID, word etherType, char sIPv4_str[], char dIPv4_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    qword sMAC,dMAC;
    sMAC=EthGetMacAddressAsNumber(sMAC_str);
    dMAC=EthGetMacAddressAsNumber(dMAC_str);
    
    SetListenBus(bus);
    
    
    ret=TestWaitForEthernetPacket(sMAC, dMAC, vlanID, etherType, IpGetAddressAsNumber(sIPv4_str), IpGetAddressAsNumber(dIPv4_str), protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_ETH_IPv4_Switch_Mode(char bus[], byte dir, ethernetPacket* pkt,char sMAC_str[], char dMAC_str[], word vlanID, word etherType, char sIPv4_str[], char dIPv4_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    
    ret=TestWaitForEth_ETH_IPv4(bus, pkt,sMAC_str, dMAC_str, vlanID, etherType, sIPv4_str, dIPv4_str, protocol, sPort, dPort, flags, aTimeout);
    
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
    }
    else
    {
        return 0;
    }
    
    
    ret=TestWaitForEth_ETH_IPv4(bus, pkt,sMAC_str, dMAC_str, vlanID, etherType, sIPv4_str, dIPv4_str, protocol, sPort, dPort, flags, aTimeout);
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        return 0;
    }
    return 0;
    
}


/// <GetEthPacket>
long TestWaitForEth_ETH_IPv6(char bus[], ethernetPacket* pkt,char sMAC_str[], char dMAC_str[], word vlanID, word etherType, char sIPv6_str[], char dIPv6_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    byte sIPv6[16], dIPv6[16];
    
    qword sMAC,dMAC;
    sMAC=EthGetMacAddressAsNumber(sMAC_str);
    dMAC=EthGetMacAddressAsNumber(dMAC_str);
    
    SetListenBus(bus);
    
    result = IpGetAddressAsArray( sIPv6_str, sIPv6);
    if (result != 0)
    {
        testStepFail("sIPv6 %s is wrong",sIPv6_str);
        return 0;
    }
    
    result = IpGetAddressAsArray( dIPv6_str, dIPv6);
    if (result != 0)
    {
        testStepFail("dIPv6 %s is wrong",dIPv6_str);
        return 0;
    }
    
    ret=TestWaitForEthernetPacket(sMAC, dMAC, vlanID, etherType, sIPv6, dIPv6, protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_ETH_IPv6_Switch_Mode(char bus[], byte dir, ethernetPacket* pkt,char sMAC_str[], char dMAC_str[], word vlanID, word etherType, char sIPv6_str[], char dIPv6_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    
    ret=TestWaitForEth_ETH_IPv6(bus, pkt,sMAC_str, dMAC_str, vlanID, etherType, sIPv6_str, dIPv6_str, protocol, sPort, dPort, flags, aTimeout);
    
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
    }
    else
    {
        return 0;
    }
    
    
    ret=TestWaitForEth_ETH_IPv6(bus, pkt,sMAC_str, dMAC_str, vlanID, etherType, sIPv6_str, dIPv6_str, protocol, sPort, dPort, flags, aTimeout);
    if(ret)
    {
        if(pkt.dir==dir)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        return 0;
    }
    return 0;
    
}

/// <SendETHPacket>
/// <SendETHPacket/SendARP>
void SendARPRequest_IPv4(
    char sMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[])
{
    ethernetPacket pkt;
    pkt.arp.Init();
//    pkt.type=0x0806;//arp
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber("FF:FF:FF:FF:FF:FF");
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    
    pkt.arp.hwType=1;//ETH 10Mb
    pkt.arp.protType=0x0800;// IPv4
    pkt.arp.hwSize=6;
    pkt.arp.protSize=4;//IPv4
    pkt.arp.operation=1;//request
    pkt.arp.hwSourceAddr=EthGetMacAddressAsNumber(sMAC_str);
    pkt.arp.protSourceAddr=IpGetAddressAsNumber(sIPv4_str);
    pkt.arp.hwDestinationAddr=EthGetMacAddressAsNumber("00:00:00:00:00:00");
    pkt.arp.protDestinationAddr=IpGetAddressAsNumber(dIPv4_str);
    pkt.CompletePacket();
    output( pkt );
}

/// <SendETHPacket/SendICMP>
void SendICMPv4_EchoRequest(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[])
{
    ethernetPacket pkt;
    pkt.icmpv4.Init();
//    pkt.type=0x0806;//arp
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    pkt.icmpv4.type=0x08;
    
    pkt.CompletePacket();
    
    output( pkt );
}


/// <SendETHPacket>
/// <SendETHPacket/SendTCP>
void SendTCP_SYNC(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[],
    dword sPort,
    dword dPort,
    dword sequence,
    dword ackNumber,
    word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x2;//SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}


/// <SendETHPacket>
/// <SendETHPacket/SendTCP>
void SendTCP_ACK_SYNC(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[],
    dword sPort,
    dword dPort,
    dword sequence,
    dword ackNumber,
    word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x12;//ACK,SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}

/// <SendETHPacket>
/// <SendETHPacket/SendTCP>
void SendTCP_ACK(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[],
    dword sPort,
    dword dPort,
    dword sequence,
    dword ackNumber,
    word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x10;//ACK,SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}

/// <SendETHPacket>
/// <SendETHPacket/SendTCP>
void SendTCP_ACK_PSH(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[],
    dword sPort,
    dword dPort,
    dword sequence,
    dword ackNumber,
    word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x18;//ACK,SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}
/// <SendETHPacket>
/// <SendETHPacket/SendUDP>
void SendUDP(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[], 
    char dIPv4_str[], 
    dword sPort, 
    dword dPort,
    byte payload[])
{
    ethernetPacket pkt;
    pkt.udp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.udp.source=sPort;
    pkt.udp.destination=dPort;
    pkt.udp.SetData(payload,elCount(payload));
    
    pkt.CompletePacket();
    output( pkt );
    
}

/// <SendETHPacket>
/// <SendETHPacket/SendSomeIP>
void SendSomeIP_Request_No_Return(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,//0xffff:不设置vlan
    char sIPv4_str[], 
    char dIPv4_str[], 
    dword sPort, 
    dword dPort,
    dword MessageID,//Service ID+Method ID,Method ID其中0 C 32767 为方法（包括 Method，Field.Getter 以及 Field.Setter），32768 C 65535 为事件（包括 Event 和 Field.Notify)
    dword RequestID,//Client ID+Session ID
    byte MessageType,
    byte payload[])
{
    ethernetPacket pkt;
    byte someip_header[16];
    dword payload_len;
    
    payload_len=elCount(payload);
    
    
    someip_header[0]=(MessageID>>24) & 0xff;
    someip_header[1]=(MessageID>>16) & 0xff;
    someip_header[2]=(MessageID>>8) & 0xff;
    someip_header[3]=(MessageID   ) & 0xff;
    
    someip_header[4]=((payload_len+8)>>24) & 0xff;
    someip_header[5]=((payload_len+8)>>16) & 0xff;
    someip_header[6]=((payload_len+8)>>8) & 0xff;
    someip_header[7]=((payload_len+8)   ) & 0xff;
    
    someip_header[8]=(RequestID>>24) & 0xff;
    someip_header[9]=(RequestID>>16) & 0xff;
    someip_header[10]=(RequestID>>8) & 0xff;
    someip_header[11]=(RequestID   ) & 0xff;
    
    someip_header[12]=1;//Protocol Version
    someip_header[13]=1;//Interface Version
    someip_header[14]=1;//REQUEST (0x00)
    someip_header[15]=0;//只在REPONSE和ERROR中用到，其他Message Type不生效，填0
    
    
    
    
    pkt.someip.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.udp.source=sPort;
    pkt.udp.destination=dPort;
    
    pkt.udp.SetData(someip_header,16);
    pkt.udp.SetData(16,payload,payload_len);//someip payload
    
    
    pkt.CompletePacket();
    output( pkt );
    
}

/// <SendETHPacket>
/// <SendETHPacket/SendSomeIP>
void SendSomeIP_Request(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,//0xffff:不设置vlan
    char sIPv4_str[], 
    char dIPv4_str[], 
    dword sPort, 
    dword dPort,
    dword MessageID,////Service ID+Method ID,Method ID其中0 C 32767 为方法（包括 Method，Field.Getter 以及 Field.Setter），32768 C 65535 为事件（包括 Event 和 Field.Notify)
    dword RequestID,//Client ID+Session ID
    byte MessageType,
    byte payload[])
{
    ethernetPacket pkt;
    byte someip_header[16];
    dword payload_len;
    
    payload_len=elCount(payload);
    
    
    someip_header[0]=(MessageID>>24) & 0xff;
    someip_header[1]=(MessageID>>16) & 0xff;
    someip_header[2]=(MessageID>>8) & 0xff;
    someip_header[3]=(MessageID   ) & 0xff;
    
    someip_header[4]=((payload_len+8)>>24) & 0xff;
    someip_header[5]=((payload_len+8)>>16) & 0xff;
    someip_header[6]=((payload_len+8)>>8) & 0xff;
    someip_header[7]=((payload_len+8)   ) & 0xff;
    
    someip_header[8]=(RequestID>>24) & 0xff;
    someip_header[9]=(RequestID>>16) & 0xff;
    someip_header[10]=(RequestID>>8) & 0xff;
    someip_header[11]=(RequestID   ) & 0xff;
    
    someip_header[12]=1;//Protocol Version
    someip_header[13]=1;//Interface Version
    someip_header[14]=0;//REQUEST (0x00)
    someip_header[15]=0;//只在REPONSE和ERROR中用到，其他Message Type不生效，填0
    
    
    
    
    pkt.someip.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.udp.source=sPort;
    pkt.udp.destination=dPort;
    
    pkt.udp.SetData(someip_header,16);
    pkt.udp.SetData(16,payload,payload_len);//someip payload
    
    
    pkt.CompletePacket();
    output( pkt );
}

/// <SendETHPacket>
/// <SendETHPacket/SendSomeIP>
void SendSomeIP_Notification(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,//0xffff:不设置vlan
    char sIPv4_str[], 
    char dIPv4_str[], 
    dword sPort, 
    dword dPort,
    dword MessageID,////Service ID+Method ID,Method ID其中0 C 32767 为方法（包括 Method，Field.Getter 以及 Field.Setter），32768 C 65535 为事件（包括 Event 和 Field.Notify)
    dword RequestID,//Client ID+Session ID
    byte MessageType,
    byte payload[])
{
    ethernetPacket pkt;
    byte someip_header[16];
    dword payload_len;
    
    payload_len=elCount(payload);
    
    
    someip_header[0]=(MessageID>>24) & 0xff;
    someip_header[1]=(MessageID>>16) & 0xff;
    someip_header[2]=(MessageID>>8) & 0xff;
    someip_header[3]=(MessageID   ) & 0xff;
    
    someip_header[4]=((payload_len+8)>>24) & 0xff;
    someip_header[5]=((payload_len+8)>>16) & 0xff;
    someip_header[6]=((payload_len+8)>>8) & 0xff;
    someip_header[7]=((payload_len+8)   ) & 0xff;
    
    someip_header[8]=(RequestID>>24) & 0xff;
    someip_header[9]=(RequestID>>16) & 0xff;
    someip_header[10]=(RequestID>>8) & 0xff;
    someip_header[11]=(RequestID   ) & 0xff;
    
    someip_header[12]=1;//Protocol Version
    someip_header[13]=1;//Interface Version
    someip_header[14]=2;//NOTIFICATION (0x02)
    someip_header[15]=0;//只在REPONSE和ERROR中用到，其他Message Type不生效，填0
    
    
    
    
    pkt.someip.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.udp.source=sPort;
    pkt.udp.destination=dPort;
    
    pkt.udp.SetData(someip_header,16);
    pkt.udp.SetData(16,payload,payload_len);//someip payload
    
    
    pkt.CompletePacket();
    output( pkt );
}

/// <SendETHPacket>
/// <SendETHPacket/SendSomeIP>
void SendSomeIP_Reponse(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,//0xffff:不设置vlan
    char sIPv4_str[], 
    char dIPv4_str[], 
    dword sPort, 
    dword dPort,
    dword MessageID,////Service ID+Method ID,Method ID其中0 C 32767 为方法（包括 Method，Field.Getter 以及 Field.Setter），32768 C 65535 为事件（包括 Event 和 Field.Notify)
    dword RequestID,//Client ID+Session ID
    byte MessageType,
    byte payload[])
{
    ethernetPacket pkt;
    byte someip_header[16];
    dword payload_len;
    
    payload_len=elCount(payload);
    
    
    someip_header[0]=(MessageID>>24) & 0xff;
    someip_header[1]=(MessageID>>16) & 0xff;
    someip_header[2]=(MessageID>>8) & 0xff;
    someip_header[3]=(MessageID   ) & 0xff;
    
    someip_header[4]=((payload_len+8)>>24) & 0xff;
    someip_header[5]=((payload_len+8)>>16) & 0xff;
    someip_header[6]=((payload_len+8)>>8) & 0xff;
    someip_header[7]=((payload_len+8)   ) & 0xff;
    
    someip_header[8]=(RequestID>>24) & 0xff;
    someip_header[9]=(RequestID>>16) & 0xff;
    someip_header[10]=(RequestID>>8) & 0xff;
    someip_header[11]=(RequestID   ) & 0xff;
    
    someip_header[12]=1;//Protocol Version
    someip_header[13]=1;//Interface Version
    someip_header[14]=0x80;//REPONSE (0x80)
    someip_header[15]=1;//只在REPONSE和ERROR中用到，其他Message Type不生效，填0
    
    
    
    
    pkt.someip.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.udp.source=sPort;
    pkt.udp.destination=dPort;
    
    pkt.udp.SetData(someip_header,16);
    pkt.udp.SetData(16,payload,payload_len);//someip payload
    
    
    pkt.CompletePacket();
    output( pkt );
}

///// <SendETHPacket>
///// <SendETHPacket/SendSomeIP>
//void SendSomeIP_SD_Offer(
//    char sMAC_str[],
//    char dMAC_str[],
//    word vlanId,//0xffff:不设置vlan
//    char sIPv4_str[], 
//    char dIPv4_str[], 
//    dword sPort, 
//    dword dPort,
//    dword MessageID,////Service ID+Method ID,Method ID其中0 C 32767 为方法（包括 Method，Field.Getter 以及 Field.Setter），32768 C 65535 为事件（包括 Event 和 Field.Notify)
//    dword RequestID,//Client ID+Session ID
//    byte MessageType,
//    byte payload[])
//{
//    ethernetPacket pkt;
//    byte someipsd_header[16];
//    dword payload_len;
//    
//    payload_len=elCount(payload);
//    
//    //Message ID：固定值 0xFFFF8100
//    someipsd_header[0]=0xff;
//    someipsd_header[1]=0xff;
//    someipsd_header[2]=0x81;
//    someipsd_header[3]=0x00;
//    
//    //Client ID：固定值 0x0000
//    someipsd_header[4]=0x00;
//    someipsd_header[5]=0x00;
//    someipsd_header[6]=0x00;
//    someipsd_header[7]=0x00;
//    
//    //Protocol Version：固定值 0x01
//    someipsd_header[8]=0x01;
//    
//    //Interface Version：固定值 0x01
//    someipsd_header[9]=0x01;
//    //Message Type：固定值 0x02（ NOTIFICATION ）
//    someipsd_header[10]=0x02;
//    //Return Code：固定值 0x00
//    someipsd_header[11]=0x00;
//    
//    //flags
//    
//    someipsd_header[12]=0x60;
//    
//    
//    
//    
//}





void MainTest ()
{
    char sMAC_str[32]="20:00:00:00:00:01";
    char dMAC_str[32]="FF:FF:FF:FF:FF:FF";
    word vlanId=1;
    char sIPv4_str[32]="192.168.0.1";
    char dIPv4_str[32]="192.168.0.2";
    dword sPort=30490;
    dword dPort=30490;
    dword MessageID=0x10010001;//Service ID+Method ID
    dword RequestID=0x00010001;//Client ID+Session ID
    byte MessageType=0;
    byte date[2]={1,2};
    
    SendSomeIP_Request(sMAC_str,dMAC_str,vlanId,sIPv4_str,dIPv4_str,sPort,dPort,MessageID,RequestID,MessageType,date);
    
    
}

