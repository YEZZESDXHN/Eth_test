/*@!Encoding:936*/
includes
{
  
}

variables
{
    struct eth_header
    {
        qword dMAC;
        qword sMAC;
        word vlanID;
        word etherType;
    };
    
    struct ipv4_header
    {
        char sIPv4Addr_str[16];
        char dIPv4Addr_str[16];
        dword protocol;
        
    };
    
    struct ipv6_header
    {
        char sIPv6Addr_str[40];
        char dIPv6Addr_str[40];
        dword protocol;
    };
  
}

//设置再哪个总线，等待报文
long SetListenBus(char listen_bus[])
{
  dword busContext;
  dword retVal;
  //Listen CAN1
  busContext = GetBusNameContext(listen_bus);
  //busContext = GetBusNameContext(eCAN,1);
  retVal =  SetBusContext(busContext);
  return retVal;
}




/// <GetEthPacket>
long TestWaitForEth_ETH(char bus[], ethernetPacket* pkt,qword sMAC, qword dMAC, word vlanID, word etherType,dword flags, dword aTimeout)
{
    long ret;
    SetListenBus(bus);
    
    ret=TestWaitForEthernetPacket(sMAC,dMAC,vlanID,etherType,flags,aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_IPv4(char bus[], ethernetPacket* pkt,char sIPv4_str[], char dIPv4_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    SetListenBus(bus);
    
    
    ret=TestWaitForEthernetPacket(IpGetAddressAsNumber(sIPv4_str), IpGetAddressAsNumber(dIPv4_str), protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_TCP_IPv4(char bus[], ethernetPacket* pkt,char sIPv4_str[], char dIPv4_str[], dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    const dword protocol=6;//TCP
    SetListenBus(bus);
    
    
    ret=TestWaitForEthernetPacket(IpGetAddressAsNumber(sIPv4_str), IpGetAddressAsNumber(dIPv4_str), protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_UDP_IPv4(char bus[], ethernetPacket* pkt,char sIPv4_str[], char dIPv4_str[], dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    const dword protocol=17;//TCP
    SetListenBus(bus);
    
    
    ret=TestWaitForEthernetPacket(IpGetAddressAsNumber(sIPv4_str), IpGetAddressAsNumber(dIPv4_str), protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_IPv6(char bus[], ethernetPacket* pkt,char sIPv6_str[], char dIPv6_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    byte sIPv6[16], dIPv6[16];
    dword result;
    
    result = IpGetAddressAsArray( sIPv6_str, sIPv6);
    if (result != 0)
    {
        testStepFail("sIPv6 %s is wrong",sIPv6_str);
        return 0;
    }
    
    result = IpGetAddressAsArray( dIPv6_str, dIPv6);
    if (result != 0)
    {
        testStepFail("dIPv6 %s is wrong",dIPv6_str);
        return 0;
    }
    
    
    SetListenBus(bus);
    
    ret=TestWaitForEthernetPacket(sIPv6, dIPv6, protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}


/// <GetEthPacket>
long TestWaitForEth_ETH_IPv4(char bus[], ethernetPacket* pkt,qword sMAC, qword dMAC, word vlanID, word etherType, char sIPv4_str[], char dIPv4_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    SetListenBus(bus);
    
    
    ret=TestWaitForEthernetPacket(sMAC, dMAC, vlanID, etherType, IpGetAddressAsNumber(sIPv4_str), IpGetAddressAsNumber(dIPv4_str), protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_ETH_IPv6(char bus[], ethernetPacket* pkt,qword sMAC, qword dMAC, word vlanID, word etherType, char sIPv6_str[], char dIPv6_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    byte sIPv6[16], dIPv6[16];
    SetListenBus(bus);
    
    result = IpGetAddressAsArray( sIPv6_str, sIPv6);
    if (result != 0)
    {
        testStepFail("sIPv6 %s is wrong",sIPv6_str);
        return 0;
    }
    
    result = IpGetAddressAsArray( dIPv6_str, dIPv6);
    if (result != 0)
    {
        testStepFail("dIPv6 %s is wrong",dIPv6_str);
        return 0;
    }
    
    ret=TestWaitForEthernetPacket(sMAC, dMAC, vlanID, etherType, sIPv6, dIPv6, protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}



/// <SendETHPacket>
/// <SendETHPacket/SendARP>
void SendARPRequest_IPv4(
    char sMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[])
{
    ethernetPacket pkt;
    pkt.arp.Init();
//    pkt.type=0x0806;//arp
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber("FF:FF:FF:FF:FF:FF");
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    
    pkt.arp.hwType=1;//ETH 10Mb
    pkt.arp.protType=0x0800;// IPv4
    pkt.arp.hwSize=6;
    pkt.arp.protSize=4;//IPv4
    pkt.arp.operation=1;//request
    pkt.arp.hwSourceAddr=EthGetMacAddressAsNumber(sMAC_str);
    pkt.arp.protSourceAddr=IpGetAddressAsNumber(sIPv4_str);
    pkt.arp.hwDestinationAddr=EthGetMacAddressAsNumber("00:00:00:00:00:00");
    pkt.arp.protDestinationAddr=IpGetAddressAsNumber(dIPv4_str);
    pkt.CompletePacket();
    output( pkt );
}

/// <SendETHPacket/SendICMP>
void SendICMPv4_EchoRequest(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[])
{
    ethernetPacket pkt;
    pkt.icmpv4.Init();
//    pkt.type=0x0806;//arp
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    pkt.icmpv4.type=0x08;
    
    pkt.CompletePacket();
    
    output( pkt );
}


/// <SendETHPacket>
/// <SendETHPacket/SendTCP>
void SendTCP_SYNC(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[],
    dword sPort,
    dword dPort,
    dword sequence,
    dword ackNumber,
    word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x2;//SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}


/// <SendETHPacket>
/// <SendETHPacket/SendTCP>
void SendTCP_ACK_SYNC(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[],
    dword sPort,
    dword dPort,
    dword sequence,
    dword ackNumber,
    word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x12;//ACK,SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}

/// <SendETHPacket>
/// <SendETHPacket/SendTCP>
void SendTCP_ACK(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[],
    dword sPort,
    dword dPort,
    dword sequence,
    dword ackNumber,
    word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x10;//ACK,SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}

/// <SendETHPacket>
/// <SendETHPacket/SendTCP>
void SendTCP_ACK_PSH(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[],
    char dIPv4_str[],
    dword sPort,
    dword dPort,
    dword sequence,
    dword ackNumber,
    word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x18;//ACK,SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}
/// <SendETHPacket>
/// <SendETHPacket/SendUDP>
void SendUDP(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,
    char sIPv4_str[], 
    char dIPv4_str[], 
    dword sPort, 
    dword dPort,
    byte payload[])
{
    ethernetPacket pkt;
    pkt.udp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.udp.source=sPort;
    pkt.udp.destination=dPort;
    pkt.udp.SetData(payload,elCount(payload));
    
    pkt.CompletePacket();
    output( pkt );
    
}

/// <SendETHPacket>
/// <SendETHPacket/SendSomeIP>
void SendSomeIP_FFMethod()
{
    ethernetPacket pkt;
    pkt.udp.Init();
    
}

/// <SendETHPacket>
/// <SendETHPacket/SendSomeIP>
void SendSomeIP_RRMethod(
    char sMAC_str[],
    char dMAC_str[],
    word vlanId,//0xffff:不设置vlan
    char sIPv4_str[], 
    char dIPv4_str[], 
    dword sPort, 
    dword dPort,
    dword MessageID,//Service ID+Method ID
    dword RequestID,//Client ID+Session ID
    byte MessageType,
    byte payload[])
{
    ethernetPacket pkt;
    byte someip_header[16];
    dword payload_len;
    
    payload_len=elCount(payload);
    
    
    someip_header[0]=(MessageID>>24) & 0xff;
    someip_header[1]=(MessageID>>16) & 0xff;
    someip_header[2]=(MessageID>>8) & 0xff;
    someip_header[3]=(MessageID   ) & 0xff;
    
    someip_header[4]=((payload_len+8)>>24) & 0xff;
    someip_header[5]=((payload_len+8)>>16) & 0xff;
    someip_header[6]=((payload_len+8)>>8) & 0xff;
    someip_header[7]=((payload_len+8)   ) & 0xff;
    
    someip_header[8]=(RequestID>>24) & 0xff;
    someip_header[9]=(RequestID>>16) & 0xff;
    someip_header[10]=(RequestID>>8) & 0xff;
    someip_header[11]=(RequestID   ) & 0xff;
    
    someip_header[12]=1;//Protocol Version
    someip_header[13]=1;//Interface Version
    someip_header[14]=MessageType;
    someip_header[15]=0;//只在REPONSE和ERROR中用到，其他Message Type不生效，填0
    
    
    
    
    pkt.someip.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    if(vlanId==0xffff)
    {
        
    }
    else
    {
        pkt.SetVlanId(vlanId);
    }
    
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.udp.source=sPort;
    pkt.udp.destination=dPort;
    
    pkt.udp.SetData(someip_header,16);
    pkt.udp.SetData(16,payload,payload_len);//someip payload
    
    
    pkt.CompletePacket();
    output( pkt );
}

/// <SendETHPacket>
/// <SendETHPacket/SendSomeIP>
void SendSomeIP_Field()
{
    
}

/// <SendETHPacket>
/// <SendETHPacket/SendSomeIP>
void SendSomeIP_getter()
{
    
}

/// <SendETHPacket>
/// <SendETHPacket/SendSomeIP>
void SendSomeIP_setter()
{
    
}





void MainTest ()
{
    char sMAC_str[32]="20:00:00:00:00:01";
    char dMAC_str[32]="FF:FF:FF:FF:FF:FF";
    word vlanId=1;
    char sIPv4_str[32]="192.168.0.1";
    char dIPv4_str[32]="192.168.0.2";
    dword sPort=30490;
    dword dPort=30490;
    dword MessageID=0x10010001;//Service ID+Method ID
    dword RequestID=0x00010001;//Client ID+Session ID
    byte MessageType=0;
    byte date[2]={1,2};
    
    SendSomeIP_RRMethod(sMAC_str,dMAC_str,vlanId,sIPv4_str,dIPv4_str,sPort,dPort,MessageID,RequestID,MessageType,date);
    
    
}

