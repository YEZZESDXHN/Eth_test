/*@!Encoding:936*/
includes
{
  
}

variables
{
    struct eth_header
    {
        qword dMAC;
        qword sMAC;
        word vlanID;
        word etherType;
    };
    
    struct ipv4_header
    {
        char sIPv4Addr_str[16];
        char dIPv4Addr_str[16];
        dword protocol;
        
    };
    
    struct ipv6_header
    {
        char sIPv6Addr_str[40];
        char dIPv6Addr_str[40];
        dword protocol;
    };
  
}

//设置再哪个总线，等待报文
long SetListenBus(char listen_bus[])
{
  dword busContext;
  dword retVal;
  //Listen CAN1
  busContext = GetBusNameContext(listen_bus);
  //busContext = GetBusNameContext(eCAN,1);
  retVal =  SetBusContext(busContext);
  return retVal;
}




/// <GetEthPacket>
long TestWaitForEth_ETH(char bus[], ethernetPacket* pkt,qword sMAC, qword dMAC, word vlanID, word etherType,dword flags, dword aTimeout)
{
    long ret;
    SetListenBus(bus);
    
    ret=TestWaitForEthernetPacket(sMAC,dMAC,vlanID,etherType,flags,aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_IPv4(char bus[], ethernetPacket* pkt,char sIPv4_str[], char dIPv4_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    SetListenBus(bus);
    
    
    ret=TestWaitForEthernetPacket(IpGetAddressAsNumber(sIPv4_str), IpGetAddressAsNumber(dIPv4_str), protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_IPv6(char bus[], ethernetPacket* pkt,char sIPv6_str[], char dIPv6_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    byte sIPv6[16], dIPv6[16];
    dword result;
    
    result = IpGetAddressAsArray( sIPv6_str, sIPv6);
    if (result != 0)
    {
        testStepFail("sIPv6 %s is wrong",sIPv6_str);
        return 0;
    }
    
    result = IpGetAddressAsArray( dIPv6_str, dIPv6);
    if (result != 0)
    {
        testStepFail("dIPv6 %s is wrong",dIPv6_str);
        return 0;
    }
    
    
    SetListenBus(bus);
    
    ret=TestWaitForEthernetPacket(sIPv6, dIPv6, protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}


/// <GetEthPacket>
long TestWaitForEth_ETH_IPv4(char bus[], ethernetPacket* pkt,qword sMAC, qword dMAC, word vlanID, word etherType, char sIPv4_str[], char dIPv4_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    SetListenBus(bus);
    
    
    ret=TestWaitForEthernetPacket(sMAC, dMAC, vlanID, etherType, IpGetAddressAsNumber(sIPv4_str), IpGetAddressAsNumber(dIPv4_str), protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}

/// <GetEthPacket>
long TestWaitForEth_ETH_IPv6(char bus[], ethernetPacket* pkt,qword sMAC, qword dMAC, word vlanID, word etherType, char sIPv6_str[], char dIPv6_str[], dword protocol, dword sPort, dword dPort, dword flags, dword aTimeout)
{
    long ret;
    dword result;
    byte sIPv6[16], dIPv6[16];
    SetListenBus(bus);
    
    result = IpGetAddressAsArray( sIPv6_str, sIPv6);
    if (result != 0)
    {
        testStepFail("sIPv6 %s is wrong",sIPv6_str);
        return 0;
    }
    
    result = IpGetAddressAsArray( dIPv6_str, dIPv6);
    if (result != 0)
    {
        testStepFail("dIPv6 %s is wrong",dIPv6_str);
        return 0;
    }
    
    ret=TestWaitForEthernetPacket(sMAC, dMAC, vlanID, etherType, sIPv6, dIPv6, protocol, sPort, dPort, flags, aTimeout);
    if(ret==1)
    {
        
    }
    else if(ret==0)
    {
        testStepFail("Resume due to timeout");
        return 0;
    }
    else if(ret==-2)
    {
        testStepFail("Resume due to constraint violation");
        return 0;
    }
    else if(ret==-1)
    {
        testStepFail("General error, for example, functionality is not available");
        return 0;
    }
    
    ret=testGetWaitEthernetPacketData(pkt);
    if(ret==0)
    {
        testStepPass("get ETH Packet success");
        return 1;
    }
    else
    {
        testStepFail("get ETH Packet failed");
        return 0;
    }
    
}



/// <SendETHPacket>
/// <SendETHPacket/SendARP>
void SendARPRequest_IPv4(char sMAC_str[],word vlanId,char sIPv4_str[], char dIPv4_str[])
{
    ethernetPacket pkt;
    pkt.arp.Init();
//    pkt.type=0x0806;//arp
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber("FF:FF:FF:FF:FF:FF");
    pkt.SetVlanId(vlanId);
    
    pkt.arp.hwType=1;//ETH 10Mb
    pkt.arp.protType=0x0800;// IPv4
    pkt.arp.hwSize=6;
    pkt.arp.protSize=4;//IPv4
    pkt.arp.operation=1;//request
    pkt.arp.hwSourceAddr=EthGetMacAddressAsNumber(sMAC_str);
    pkt.arp.protSourceAddr=IpGetAddressAsNumber(sIPv4_str);
    pkt.arp.hwDestinationAddr=EthGetMacAddressAsNumber("00:00:00:00:00:00");
    pkt.arp.protDestinationAddr=IpGetAddressAsNumber(dIPv4_str);
    pkt.CompletePacket();
    output( pkt );
}

/// <SendETHPacket/SendICMP>
void SendICMPv4_EchoRequest(char sMAC_str[],char dMAC_str[],word vlanId,char sIPv4_str[], char dIPv4_str[])
{
    ethernetPacket pkt;
    pkt.icmpv4.Init();
//    pkt.type=0x0806;//arp
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    pkt.SetVlanId(vlanId);
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    pkt.icmpv4.type=0x08;
    
    pkt.CompletePacket();
    
    output( pkt );
}



void SendTCP_SYNC(char sMAC_str[],char dMAC_str[],word vlanId,char sIPv4_str[], char dIPv4_str[], dword sPort, dword dPort,dword sequence,dword ackNumber,word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    pkt.SetVlanId(vlanId);
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x2;//SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}

void SendTCP_ACK_SYNC(char sMAC_str[],char dMAC_str[],word vlanId,char sIPv4_str[], char dIPv4_str[], dword sPort, dword dPort,dword sequence,dword ackNumber,word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    pkt.SetVlanId(vlanId);
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x12;//ACK,SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}

void SendTCP_ACK(char sMAC_str[],char dMAC_str[],word vlanId,char sIPv4_str[], char dIPv4_str[], dword sPort, dword dPort,dword sequence,dword ackNumber,word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    pkt.SetVlanId(vlanId);
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x10;//ACK,SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}

void SendTCP_ACK_PSH(char sMAC_str[],char dMAC_str[],word vlanId,char sIPv4_str[], char dIPv4_str[], dword sPort, dword dPort,dword sequence,dword ackNumber,word window)
{
    ethernetPacket pkt;
    pkt.tcp.Init();
    pkt.source=EthGetMacAddressAsNumber(sMAC_str);
    pkt.destination=EthGetMacAddressAsNumber(dMAC_str);
    pkt.SetVlanId(vlanId);
    pkt.ipv4.source=IpGetAddressAsNumber(sIPv4_str);
    pkt.ipv4.destination=IpGetAddressAsNumber(dIPv4_str);
    
    pkt.tcp.source=sPort;
    pkt.tcp.destination=dPort;
    pkt.tcp.sequence=sequence;
    pkt.tcp.ackNumber=ackNumber;
    pkt.tcp.flags=0x18;//ACK,SYNC
    pkt.tcp.window=window;
    
    pkt.CompletePacket();
    output( pkt );
}



void MainTest ()
{
    ethernetPacket pkt;
    long ret;
    
    
    SetListenBus("Ethernet1");
    
    
    write("start");
    ret=TestWaitForEthernetPacket(IpGetAddressAsNumber("192.168.1.1"), IpGetAddressAsNumber("192.168.1.255"), 17, 0, 0, 0, 10000);
    
    write("ret=%d",ret);
    if(ret==1)
    {
        write("Resume due to event occurred");
        ret=testGetWaitEthernetPacketData(pkt);
        if(ret==0)
        {
            write("Data access successful");
        }
    }
    
    
    
}

